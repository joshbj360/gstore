import prisma from '~/server/prisma/prismaClient';
import { serverSupabaseUser } from '#supabase/server';
import { z } from 'zod';
import type { IProduct } from '~/models';
import { fa } from 'zod/v4/locales';

// The Zod schema is correct. It defines how we receive the data from the client.
const productCreateSchema = z.object({
    title: z.string().min(3, 'Title must be at least 3 characters long.'),
    description: z.string().optional(),
    price: z.number().positive('Price must be a positive number.'),
    discount: z.number().optional().nullable(),
    shippingZoneId: z.string().uuid('A valid shipping profile is required.'),
    category: z.object({ name: z.string() }),
    tags: z.array(z.object({ name: z.string() })),
    variants: z.array(z.object({
        size: z.string().min(1),
        stock: z.number().int().min(0),
        price: z.number().positive().nullable(),
    })).min(1, "At least one product variant is required."),
    media: z.array(z.object({
        url: z.string().url(),
        type: z.string(),
        public_id: z.string(),
        width: z.number().optional(),
        height: z.number().optional(),
    })).min(1, "At least one media file is required."),
    linkedProductIds: z.array(z.number()).optional(),
    isAccessory: z.boolean().optional()
});

export default defineEventHandler(async (event) => {
    const user = await serverSupabaseUser(event);
    if (!user) throw createError({ statusCode: 401, message: 'Unauthorized' });

    const sellerProfile = await prisma.sellerProfile.findUnique({ where: { profileId: user.id } });
    if (!sellerProfile) throw createError({ statusCode: 403, message: 'Seller profile not found.' });

    const validation = await readValidatedBody(event, body => productCreateSchema.safeParse(body));
    if (!validation.success) {
        throw createError({ 
            statusCode: 400, 
            statusMessage: 'Invalid product data',
            message: validation.error.issues.map(i => i.message).join(', ')
        });
    }

    const body = validation.data;

    try {
        const newProductWithRelations = await prisma.$transaction(async (tx) => {
            // Step 1: Create the main product record
            const product = await tx.products.create({
                data: {
                    title: body.title,
                    description: body.description,
                    price: body.price,
                    discount: body.discount,
                    sellerId: sellerProfile.id,
                    shippingZoneId: body.shippingZoneId,
                    isAccessory: body.isAccessory || false,
                    SKU: `SKU-${Math.random().toString(36).substring(2, 8).toUpperCase()}`, // Simple SKU generation
                    slug: '', // Dummy value, will be generated by the Prisma extension
                    category: {
                        create: [{
                            category: {
                                connectOrCreate: {
                                    where: { name: body.category.name },
                                    create: { name: body.category.name, slug: body.category.name.toLowerCase().replace(/\s+/g, '-') }
                                }
                            }
                        }]
                    },
                    tags: {
                        create: body.tags.map(tag => ({
                            tag: { connectOrCreate: { where: { name: tag.name }, create: { name: tag.name } } }
                        }))
                    },
                    variants: {
                        create: body.variants.map(variant => ({
                            size: variant.size,
                            stock: variant.stock,
                            price: variant.price
                        }))
                    },
                    media: {
                        create: body.media.map(mediaItem => ({
                            url: mediaItem.url,
                            type: mediaItem.type as any,
                            public_id: mediaItem.public_id,
                            metadata: { width: mediaItem.width, height: mediaItem.height },
                            sellerId: sellerProfile.id
                        }))
                    }
                }
            });

            // THE FIX: Handle the "Shop the Look" relations correctly.
            // After the product is created, we use its new ID to create the relationships
            // in the `ProductRelation` join table.
            if (body.linkedProductIds && body.linkedProductIds.length > 0) {
                await tx.productRelation.createMany({
                    data: body.linkedProductIds.map(id => ({
                        styledWithId: product.id, // The new product is the "main look"
                        appearsInId: id          // The linked items are the "accessories"
                    }))
                });
            }

            // Return the full product with all its new relations
            return tx.products.findUnique({
                where: { id: product.id },
                include: { media: true, variants: true, category: true, tags: true, styledWith: true }
            });
        });

        return newProductWithRelations;

    } catch (error: any) {
        console.error("Error creating product:", error);
        throw createError({ statusCode: 500, message: error.message || 'Failed to create product.' });
    }
});

